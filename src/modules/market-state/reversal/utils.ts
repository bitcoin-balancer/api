/* eslint-disable @typescript-eslint/brace-style */
import { calculatePercentageRepresentation, processValue } from 'bignumber-utils';
import { generateUUID } from '../../shared/uuid/index.js';
import { ISplitStateID, IState } from '../shared/types.js';
import { IWindowState } from '../window/types.js';
import { ICompactLiquidityState } from '../liquidity/index.js';
import { ICoinsState, ICoinsStates, ISemiCompactCoinState } from '../coins/index.js';
import {
  IPriceCrashStateRecord,
  IReversalConfig,
  IReversalPoints,
  IReversalPointWeights,
  IReversalState,
} from './types.js';

/* ************************************************************************************************
 *                                        POINT CALCULATORS                                       *
 ************************************************************************************************ */

/**
 * Calculates the points generated by the Liquidity Module. The higher the bid dominance, the higher
 * the points.
 * @param liquidityState
 * @param weight
 * @returns number
 */
const __calculateLiquidityPoints = (
  { bidDominance }: ICompactLiquidityState,
  weight: number,
): number => {
  const score = Math.max(0.01, Math.min(1.00, (bidDominance - 2) / 98));
  return processValue(score * weight);
};

/**
 * Calculates the score (not points!) obtained by a single split.
 * @param splitState
 * @returns number
 */
const __calculateScoreForSplit = (splitState: IState): number => {
  switch (splitState) {
    case 2:
      return 1;
    case 1:
      return 0.75;
    case -1:
      return 0.25;
    case -2:
      return 0;
    default:
      return 0.5;
  }
};

/**
 * Calculates the total score for all symbols based on their split states.
 * @param states
 * @param stateSplits
 * @returns number
 */
const __calculateScoreForSymbols = (
  states: ISemiCompactCoinState[],
  stateSplits: ISplitStateID[],
): number => states.reduce(
  (previous, current) => (
    previous + stateSplits.reduce(
      (previousInner, currentInner) => (
        previousInner + __calculateScoreForSplit(current.splitStates[currentInner].state)
      ),
      0,
    )
  ),
  0,
);

/**
 * Calculates the state for the state of the coins (quote or base).
 * @param coinsState
 * @param stateSplits
 * @param weight
 * @returns number
 */
const __calculateCoinsPoints = (
  { statesBySymbol }: ICoinsState<ISemiCompactCoinState>,
  stateSplits: ISplitStateID[],
  weight: number,
): number => {
  // init the state for all symbols
  const states = Object.values(statesBySymbol);

  // calculate the score obtained by all the symbols
  const score: number = __calculateScoreForSymbols(states, stateSplits);

  // the highest possible score that can be obtained by all symbols combined
  const highest = states.length * stateSplits.length;

  // calculate the score received based the highest possible one
  const received = calculatePercentageRepresentation(score, highest);

  // finally, turn the score into reversal points and return it
  return processValue((received / 100) * weight);
};


/**
 * Calculates the points for each module as well as the total.
 * @param liquidityState
 * @param coinsStates
 * @returns IReversalPoints
 */
const calculatePoints = (
  liquidityState: ICompactLiquidityState,
  coinsStates: ICoinsStates<ISemiCompactCoinState>,
  stateSplits: ISplitStateID[],
  weights: IReversalPointWeights,
): IReversalPoints => {
  // init values
  let total: number = 0;

  // calculate the liquidity points
  const liquidity = __calculateLiquidityPoints(liquidityState, weights.liquidity);
  total += liquidity;

  // calculate the coins quote points
  const coinsQuote = __calculateCoinsPoints(coinsStates.quote, stateSplits, weights.coinsQuote);
  total += coinsQuote;

  // calculate the coins base points
  const coinsBase = __calculateCoinsPoints(coinsStates.base, stateSplits, weights.coinsBase);
  total += coinsBase;

  // finally, return the points build
  return {
    total: processValue(total),
    liquidity,
    coinsQuote,
    coinsBase,
  };
};





/* ************************************************************************************************
 *                                          STATE HELPERS                                         *
 ************************************************************************************************ */

/**
 * Builds the price crash state object in pristine state.
 * @returns IPriceCrashStateRecord
 */
const buildPristinePriceCrashState = (): IPriceCrashStateRecord => ({
  id: generateUUID(),
  highest_points: 0,
  final_points: 0,
  event_time: Date.now(),
  reversal_event_time: null,
});

/**
 * Calculates the time at which the price crash state will fade away.
 * @param currentTime
 * @param crashDuration
 * @returns number
 */
const calculateCrashStateDuration = (currentTime: number, crashDuration: number): number => (
  currentTime + ((crashDuration * 60) * 1000)
);

/**
 * Checks if the price has just crashed and a new state should be created.
 * @param window
 * @param activeUntil
 * @returns boolean
 */
const isNewPriceCrashState = (window: IWindowState, activeUntil: number | undefined): boolean => (
  activeUntil === undefined && window.state === -2
);

/**
 * Checks if the price crash state has ended and should be wrapped up.
 * @param currentTime
 * @param activeUntil
 * @returns boolean
 */
const hasPriceCrashStateEnded = (currentTime: number, activeUntil: number | undefined): boolean => (
  typeof activeUntil === 'number' && currentTime > activeUntil
);

/**
 * Checks if there is an active price crash state and should be updated with the new data.
 * @param currentTime
 * @param activeUntil
 * @returns boolean
 */
const isPriceCrashStateActive = (
  currentTime: number,
  activeUntil: number | undefined,
  state: IPriceCrashStateRecord | undefined,
): boolean => (
  typeof activeUntil === 'number' && activeUntil > currentTime && state !== undefined
);

/**
 * Transforms a price crash state record into a reversal state ready to be inserted into the
 * Market State.
 * @param state
 * @param pointsRequirement
 * @returns IReversalState
 */
const toReversalState = (
  state: IPriceCrashStateRecord,
  pointsRequirement: number,
): IReversalState => {
  const percentage = calculatePercentageRepresentation(
    state.final_points,
    pointsRequirement,
    { roundingMode: 'ROUND_HALF_DOWN' },
  );
  return {
    id: state.id,
    points: percentage > 100 ? 100 : percentage,
    reversalEventTime: state.reversal_event_time,
  };
};





/* ************************************************************************************************
 *                                         CONFIG HELPERS                                         *
 ************************************************************************************************ */

/**
 * Builds the default module's configuration object.
 * @returns IReversalConfig
 */
const buildDefaultConfig = (): IReversalConfig => ({
  crashDuration: 360,
  pointsRequirement: 78,
  weights: {
    liquidity: 35,
    coinsQuote: 32.5,
    coinsBase: 32.5,
  },
});





/* ************************************************************************************************
 *                                         MODULE EXPORTS                                         *
 ************************************************************************************************ */
export {
  // point calculators
  calculatePoints,

  // state helpers
  buildPristinePriceCrashState,
  calculateCrashStateDuration,
  isNewPriceCrashState,
  hasPriceCrashStateEnded,
  isPriceCrashStateActive,
  toReversalState,

  // config helpers
  buildDefaultConfig,
};
